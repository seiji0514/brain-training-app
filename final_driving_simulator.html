<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>【完成版】高精度3D運転シミュレーター</title>
    <style>
        body { margin: 0; background-color: #000; color: #fff; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
            font-family: 'Helvetica Neue', 'Arial', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', 'Meiryo', sans-serif;
            font-size: 24px;
            font-weight: 300;
            text-shadow: 0 0 8px #000, 0 0 8px #000;
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <div id="info">
        高精度3D運転シミュレーター<br>
        <span style="font-size: 16px;">(社会復帰支援プログラム)</span>
    </div>
    <div id="loader">プログラムを準備中...</div>

    <!-- 3Dライブラリ (Import Map) -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        const loaderElement = document.getElementById('loader');

        // スクリプトを動的に読み込み、完了を待つ関数
        function loadScript(src) {
            loaderElement.innerHTML = `物理エンジンを読み込み中...`;
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = () => resolve();
                script.onerror = () => reject(new Error(`スクリプトの読み込みに失敗: ${src}`));
                document.head.appendChild(script);
            });
        }

        // メイン処理
        async function main() {
            try {
                // 1. 物理エンジンを確実に読み込む
                await loadScript('https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js');
                
                // 2. 物理エンジンの読み込みが完了してから、シミュレーターを初期化
                loaderElement.innerHTML = `3Dモデルを読み込み中...`;
                runSimulator();

            } catch (error) {
                console.error("初期化エラー:", error);
                loaderElement.innerHTML = `エラー: ${error.message}`;
                loaderElement.style.color = 'red';
            }
        }

        function runSimulator() {
            let camera, scene, renderer, world;
            let carMesh, carBody;
            const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

            init();
            animate();

            function init() {
                world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
                world.broadphase = new CANNON.SAPBroadphase(world);
                world.solver.iterations = 10;

                const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
                groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
                world.addBody(groundBody);

                camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(4.25, 1.4, -4.5);
                scene = new THREE.Scene();

                new RGBELoader()
                    .setPath('https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/textures/equirectangular/')
                    .load('venice_sunset_1k.hdr', 
                    (texture) => {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        scene.background = texture;
                        scene.environment = texture;
                    }, undefined, (err) => {
                        loaderElement.innerHTML = 'エラー: 背景の読み込みに失敗しました。';
                        loaderElement.style.color = 'red';
                    });

                const groundMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(100, 100),
                    new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.9, roughness: 0.4 })
                );
                groundMesh.rotation.x = -Math.PI / 2;
                groundMesh.receiveShadow = true;
                scene.add(groundMesh);

                const carShape = new CANNON.Box(new CANNON.Vec3(1.1, 0.5, 2.4));
                carBody = new CANNON.Body({ mass: 1500 });
                carBody.addShape(carShape);
                carBody.position.y = 1;
                world.addBody(carBody);
                
                const dracoLoader = new DRACOLoader().setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                new GLTFLoader().setDRACOLoader(dracoLoader).load('https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/models/ferrari.glb', 
                (gltf) => {
                    carMesh = gltf.scene;
                    carMesh.traverse(child => { if (child.isMesh) child.castShadow = true; });
                    carMesh.scale.set(0.6, 0.6, 0.6);
                    scene.add(carMesh);
                    loaderElement.style.display = 'none';
                }, undefined, (err) => {
                    loaderElement.innerHTML = 'エラー: 車両モデルの読み込みに失敗しました。';
                    loaderElement.style.color = 'red';
                });

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 0.85;
                document.body.appendChild(renderer.domElement);

                document.addEventListener('keydown', (e) => { if (e.key in keys) keys[e.key] = true; });
                document.addEventListener('keyup', (e) => { if (e.key in keys) keys[e.key] = false; });
                window.addEventListener('resize', onWindowResize);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function animate() {
                requestAnimationFrame(animate);
                world.step(1 / 60);

                if (carMesh && carBody) {
                    carMesh.position.copy(carBody.position);
                    carMesh.quaternion.copy(carBody.quaternion);

                    const force = 30000;
                    const torque = 15000;

                    carBody.angularVelocity.y *= 0.95;

                    if (keys.ArrowUp) carBody.applyLocalForce(new CANNON.Vec3(0, 0, -force), new CANNON.Vec3(0, 0, 0));
                    if (keys.ArrowDown) carBody.applyLocalForce(new CANNON.Vec3(0, 0, force * 0.5), new CANNON.Vec3(0, 0, 0));
                    if (keys.ArrowLeft) carBody.applyLocalTorque(new CANNON.Vec3(0, torque, 0));
                    if (keys.ArrowRight) carBody.applyLocalTorque(new CANNON.Vec3(0, -torque, 0));
                    
                    const relativeCameraOffset = new THREE.Vector3(0, 3, 7);
                    const cameraOffset = carMesh.localToWorld(relativeCameraOffset);
                    camera.position.lerp(cameraOffset, 0.08);
                    camera.lookAt(carMesh.position);
                }
                renderer.render(scene, camera);
            }
        }

        main();
    </script>
</body>
</html> 