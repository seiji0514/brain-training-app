<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>【診断機能付】3D運転リハビリテーション・シミュレーター</title>
    <style>
        body { margin: 0; background-color: #000; color: #fff; overflow: hidden; }
        canvas { display: block; }
        .ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: calc(100% - 20px);
            z-index: 100;
            font-family: 'Helvetica Neue', 'Arial', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', 'Meiryo', sans-serif;
            text-shadow: 0 0 8px #000, 0 0 8px #000;
        }
        #info {
            text-align: center;
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 20px;
        }
        #diagnostic-panel {
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            max-width: 450px;
            margin: 0 auto;
            text-align: center;
        }
        #instructions {
            font-size: 18px;
            font-weight: bold;
            color: #ffc107; /* Amber color for visibility */
            margin-bottom: 10px;
            height: 40px;
        }
        #result {
            font-size: 22px;
            color: #4caf50; /* Green for success */
            height: 30px;
        }
        #restart-button {
            background-color: #3498db;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin-top: 10px;
            cursor: pointer;
            border-radius: 5px;
            display: none; /* Initially hidden */
        }
        #loader {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px; font-family: sans-serif;
        }
    </style>
</head>
<body>
    <div class="ui-container">
        <div id="info">
            3D運転技能診断<br>
            <span style="font-size: 16px;">(ブレーキ反応テスト)</span>
        </div>
        <div id="diagnostic-panel">
            <div id="instructions">準備中...</div>
            <div id="result"></div>
            <button id="restart-button">再テスト</button>
        </div>
    </div>
    <div id="loader">プログラムを準備中...</div>

    <!-- Base libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const loaderElement = document.getElementById('loader');

            if (typeof THREE === 'undefined' || typeof CANNON === 'undefined') {
                loaderElement.innerHTML = '致命的エラー: 基幹ライブラリが読み込めません。';
                loaderElement.style.color = 'red';
                return;
            }

            const loaderUrls = [
                'https://unpkg.com/three@0.128.0/examples/js/loaders/RGBELoader.js',
            ];

            function loadScript(url) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = url;
                    script.onload = resolve;
                    script.onerror = () => reject(new Error(`スクリプトの読み込みに失敗: ${url.split('/').pop()}`));
                    document.head.appendChild(script);
                });
            }

            loaderElement.innerHTML = '追加コンポーネントを読み込み中...';
            Promise.all(loaderUrls.map(loadScript))
                .then(() => {
                    if (typeof THREE.RGBELoader === 'undefined') {
                        throw new Error('追加コンポーネントの初期化に失敗しました。');
                    }
                    loaderElement.innerHTML = 'シミュレーターを起動中...';
                    runSimulator();
                })
                .catch(error => {
                    console.error("起動エラー:", error);
                    loaderElement.innerHTML = `致命的なエラー: ${error.message}`;
                    loaderElement.style.color = 'red';
                });
            
            function runSimulator() {
                let camera, scene, renderer, world, vehicle;
                const carModel = new THREE.Group();
                const wheelMeshes = [];

                // Diagnostic state
                let testState = 'idle'; // idle, waiting, triggered, finished
                let startTime, reactionTime;
                let stopSignalMesh;
                let testTimeout;
                
                const instructionsEl = document.getElementById('instructions');
                const resultEl = document.getElementById('result');
                const restartBtn = document.getElementById('restart-button');

                init();
                animate();

                function init() {
                    world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
                    world.broadphase = new CANNON.SAPBroadphase(world);

                    const groundMaterial = new CANNON.Material("ground");
                    const wheelMaterial = new CANNON.Material("wheel");
                    world.addContactMaterial(new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
                        friction: 0.3, restitution: 0, contactEquationStiffness: 1000,
                    }));

                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.set(4, 2, 5);
                    scene = new THREE.Scene();

                    new THREE.RGBELoader()
                        .load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr', (texture) => {
                            texture.mapping = THREE.EquirectangularReflectionMapping;
                            scene.background = texture;
                            scene.environment = texture;
                            loaderElement.style.display = 'none';
                        }, undefined, () => {
                             scene.background = new THREE.Color(0x87ceeb);
                             loaderElement.style.display = 'none';
                        });

                    const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial, shape: new CANNON.Plane() });
                    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                    world.addBody(groundBody);

                    const groundMesh = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.4 }));
                    groundMesh.rotation.x = -Math.PI / 2;
                    scene.add(groundMesh);
                    
                    const chassisBody = new CANNON.Body({ mass: 150, shape: new CANNON.Box(new CANNON.Vec3(1, 0.3, 2)) });
                    chassisBody.position.set(0, 1, 0);
                    vehicle = new CANNON.RaycastVehicle({ chassisBody: chassisBody });

                    const wheelOptions = {
                        radius: 0.35, directionLocal: new CANNON.Vec3(0, -1, 0), suspensionStiffness: 30,
                        suspensionRestLength: 0.3, frictionSlip: 5, maxSuspensionTravel: 0.3, material: wheelMaterial
                    };
                    const wheelPositions = [
                        new CANNON.Vec3(-1, 0, 1.7), new CANNON.Vec3(1, 0, 1.7),
                        new CANNON.Vec3(-1, 0, -1.7), new CANNON.Vec3(1, 0, -1.7)
                    ];
                    wheelPositions.forEach(pos => vehicle.addWheel({ ...wheelOptions, chassisConnectionPointLocal: pos }));
                    vehicle.addToWorld(world);

                    const chassisMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 0.6, 4), new THREE.MeshStandardMaterial({ color: 0xcc0000, metalness: 0.9, roughness: 0.2 }));
                    carModel.add(chassisMesh);
                    const cabinMesh = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.8, 2), new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.2 }));
                    cabinMesh.position.set(0, 0.7, -0.5);
                    carModel.add(cabinMesh);
                    scene.add(carModel);

                    const wheelGeo = new THREE.CylinderGeometry(wheelOptions.radius, wheelOptions.radius, 0.3, 26);
                    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.5, roughness: 0.5 });
                    vehicle.wheelInfos.forEach(() => {
                        const wheelMesh = new THREE.Mesh(wheelGeo, wheelMat);
                        wheelMeshes.push(wheelMesh);
                        scene.add(wheelMesh);
                    });
                    
                    renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    document.body.appendChild(renderer.domElement);
                    
                    setupEventListeners();
                    startTest();
                }

                function startTest() {
                    clearTimeout(testTimeout);
                    testState = 'waiting';
                    instructionsEl.textContent = 'アクセル(↑キー)で発進し、直進してください。';
                    instructionsEl.style.color = '#ffc107';
                    resultEl.textContent = '';
                    restartBtn.style.display = 'none';

                    if (stopSignalMesh) scene.remove(stopSignalMesh);
                    
                    vehicle.chassisBody.position.set(0, 1, 0);
                    vehicle.chassisBody.quaternion.set(0, 0, 0, 1);
                    vehicle.chassisBody.velocity.set(0, 0, 0);
                    vehicle.chassisBody.angularVelocity.set(0, 0, 0);
                    vehicle.applyEngineForce(0,2); vehicle.applyEngineForce(0,3);
                    vehicle.setBrake(0,0); vehicle.setBrake(0,1); vehicle.setBrake(0,2); vehicle.setBrake(0,3);


                    const randomDelay = Math.random() * 4000 + 3000; // 3-7 seconds
                    testTimeout = setTimeout(showStopSignal, randomDelay);
                }

                function showStopSignal() {
                    if (testState !== 'waiting') return;

                    testState = 'triggered';
                    instructionsEl.textContent = 'ブレーキ(↓キーまたはスペース)を踏んで！';
                    instructionsEl.style.color = '#e74c3c';
                    
                    const stopGeo = new THREE.BoxGeometry(2, 2, 2);
                    const stopMat = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000 });
                    stopSignalMesh = new THREE.Mesh(stopGeo, stopMat);
                    
                    const carPosition = vehicle.chassisBody.position;
                    stopSignalMesh.position.set(carPosition.x, carPosition.y + 1, carPosition.z - 20);
                    scene.add(stopSignalMesh);

                    startTime = performance.now();
                }
                
                function endTest() {
                    reactionTime = performance.now() - startTime;
                    testState = 'finished';
                    instructionsEl.textContent = 'テスト完了';
                    instructionsEl.style.color = '#27ae60';
                    resultEl.textContent = `反応時間: ${reactionTime.toFixed(0)} ミリ秒`;
                    restartBtn.style.display = 'block';

                    const brakeForce = 100;
                    vehicle.setBrake(brakeForce, 0); vehicle.setBrake(brakeForce, 1);
                    vehicle.setBrake(brakeForce, 2); vehicle.setBrake(brakeForce, 3);
                    vehicle.applyEngineForce(0, 2); vehicle.applyEngineForce(0, 3);
                }
                
                function setupEventListeners() {
                    document.addEventListener('keydown', (e) => {
                        const maxForce = 800;
                        if (testState === 'finished') return;

                        switch(e.key) {
                            case 'w': case 'ArrowUp': 
                                if (testState === 'waiting') {
                                     vehicle.applyEngineForce(-maxForce, 2); vehicle.applyEngineForce(-maxForce, 3);
                                }
                                break;
                            case 's': case 'ArrowDown':
                            case ' ': // Space bar for brake
                                if(testState === 'triggered') {
                                    endTest();
                                }
                                e.preventDefault();
                                break;
                        }
                    });

                    document.addEventListener('keyup', (e) => {
                        if (testState === 'finished') return;
                        switch(e.key) {
                            case 'w': case 'ArrowUp': 
                                vehicle.applyEngineForce(0, 2); vehicle.applyEngineForce(0, 3);
                                break;
                        }
                    });

                    restartBtn.addEventListener('click', startTest);
                    window.addEventListener('resize', onWindowResize);
                }

                function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }

                function animate() {
                    requestAnimationFrame(animate);
                    world.step(1 / 60);

                    carModel.position.copy(vehicle.chassisBody.position);
                    carModel.quaternion.copy(vehicle.chassisBody.quaternion);
                    
                    vehicle.wheelInfos.forEach((wheel, i) => {
                        vehicle.updateWheelTransform(i);
                        const t = wheel.worldTransform;
                        wheelMeshes[i].position.copy(t.position);
                        wheelMeshes[i].quaternion.copy(t.quaternion);
                    });

                    if (testState !== 'finished') {
                        const cameraOffset = carModel.localToWorld(new THREE.Vector3(0, 4, 9));
                        camera.position.lerp(cameraOffset, 0.1);
                        camera.lookAt(carModel.position);
                    }
                    
                    renderer.render(scene, camera);
                }
            }
        });
    </script>
</body>
</html>
