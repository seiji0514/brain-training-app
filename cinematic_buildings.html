<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯ 3Då»ºç‰©ç¾¤</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Meiryo', sans-serif;
      background: #000;
      overflow: hidden;
    }
    
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      z-index: 100;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 15px;
      max-width: 400px;
      border: 2px solid #ff6b35;
      backdrop-filter: blur(10px);
    }
    
    #cinematic-info {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      z-index: 100;
      background: rgba(0, 0, 0, 0.9);
      padding: 15px;
      border-radius: 15px;
      border: 2px solid #4ecdc4;
      backdrop-filter: blur(10px);
    }
    
    #scene-title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 48px;
      font-weight: bold;
      text-align: center;
      z-index: 200;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      opacity: 0;
      transition: opacity 2s;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      color: #fff;
    }
    
    input, select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ff6b35;
      border-radius: 4px;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
    }
    
    button {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      margin: 5px;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
    }
    
    button.secondary {
      background: linear-gradient(45deg, #4ecdc4, #44a08d);
    }
    
    button.secondary:hover {
      box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
    }
    
    .coordinates {
      display: flex;
      gap: 10px;
    }
    
    .coordinates input {
      flex: 1;
    }
    
    .error {
      background: rgba(255, 0, 0, 0.2);
      color: #ff6b6b;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      border: 1px solid #ff6b6b;
    }
    
    .success {
      background: rgba(0, 255, 0, 0.2);
      color: #51cf66;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      border: 1px solid #51cf66;
    }
    
    #message {
      margin-top: 10px;
    }
    
    #cinematic-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 50;
    }
    
    .film-grain {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/></filter><rect width="100" height="100" filter="url(%23noise)" opacity="0.05"/></svg>');
      opacity: 0.1;
    }
    
    .vignette {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.3) 70%);
    }
    
    #camera-path {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      z-index: 100;
      background: rgba(0, 0, 0, 0.9);
      padding: 15px 30px;
      border-radius: 20px;
      border: 2px solid #ff6b35;
      backdrop-filter: blur(10px);
    }
    
    .camera-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .camera-btn {
      background: rgba(255, 107, 53, 0.3);
      border: 1px solid #ff6b35;
      color: white;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .camera-btn:hover {
      background: rgba(255, 107, 53, 0.6);
    }
    
    .camera-btn.active {
      background: #ff6b35;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    
    <!-- ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
    <div id="cinematic-overlay">
      <div class="film-grain"></div>
      <div class="vignette"></div>
    </div>
    
    <!-- ã‚·ãƒ¼ãƒ³ã‚¿ã‚¤ãƒˆãƒ« -->
    <div id="scene-title">ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯ 3Då»ºç‰©ç¾¤</div>
    
    <div id="controls">
      <h3>ğŸ¬ ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯ 3Då»ºç‰©ç¾¤</h3>
      
      <div class="form-group">
        <label>ã‚¨ãƒªã‚¢é¸æŠ:</label>
        <select id="areaSelect">
          <option value="takeo_hospital">æ–°æ­¦é›„ç—…é™¢è¿‘éƒŠ</option>
          <option value="saga_center">ä½è³€å¸‚ä¸­å¿ƒéƒ¨</option>
          <option value="karatsu_castle">å”æ´¥åŸå‘¨è¾º</option>
          <option value="nagasaki_station">é•·å´é§…å‘¨è¾º</option>
          <option value="custom">ã‚«ã‚¹ã‚¿ãƒ åº§æ¨™</option>
        </select>
      </div>
      
      <div class="form-group">
        <label>åº§æ¨™ç¯„å›²:</label>
        <div class="coordinates">
          <input type="number" id="minLat" placeholder="æœ€å°ç·¯åº¦" step="0.0001">
          <input type="number" id="maxLat" placeholder="æœ€å¤§ç·¯åº¦" step="0.0001">
        </div>
        <div class="coordinates">
          <input type="number" id="minLng" placeholder="æœ€å°çµŒåº¦" step="0.0001">
          <input type="number" id="maxLng" placeholder="æœ€å¤§çµŒåº¦" step="0.0001">
        </div>
      </div>
      
      <div class="form-group">
        <label>ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯è¨­å®š:</label>
        <select id="cinematicMode">
          <option value="dramatic">ãƒ‰ãƒ©ãƒãƒ†ã‚£ãƒƒã‚¯</option>
          <option value="action">ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</option>
          <option value="mystery">ãƒŸã‚¹ãƒ†ãƒªãƒ¼</option>
          <option value="romantic">ãƒ­ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯</option>
        </select>
      </div>
      
      <button onclick="loadBuildings()">å»ºç‰©ç¾¤èª­ã¿è¾¼ã¿</button>
      <button class="secondary" onclick="startCinematic()">ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯é–‹å§‹</button>
      <button class="secondary" onclick="createSampleBuildings()">ã‚µãƒ³ãƒ—ãƒ«å»ºç‰©ä½œæˆ</button>
      
      <div id="message"></div>
    </div>
    
    <div id="cinematic-info">
      <h4>ğŸ¥ ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯æƒ…å ±</h4>
      <div>ã‚«ãƒ¡ãƒ©ãƒ¯ãƒ¼ã‚¯: <span id="camera-work">é™æ­¢</span></div>
      <div>ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°: <span id="lighting">æ¨™æº–</span></div>
      <div>ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ: <span id="effects">ãªã—</span></div>
      <div>éŸ³æ¥½: <span id="music">ã‚ªãƒ•</span></div>
    </div>
    
    <div id="camera-path">
      <div class="camera-controls">
        <div class="camera-btn" onclick="setCameraPath('orbit')">è»Œé“æ’®å½±</div>
        <div class="camera-btn" onclick="setCameraPath('flyover')">ä¸Šç©ºé£›è¡Œ</div>
        <div class="camera-btn" onclick="setCameraPath('street')">ã‚¹ãƒˆãƒªãƒ¼ãƒˆè¦–ç‚¹</div>
        <div class="camera-btn" onclick="setCameraPath('dramatic')">ãƒ‰ãƒ©ãƒãƒ†ã‚£ãƒƒã‚¯</div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let buildings = [];
    let cinematicMode = 'dramatic';
    let cameraPath = 'orbit';
    let isCinematic = false;
    let time = 0;
    let cameraTarget = new THREE.Vector3(0, 0, 0);
    
    // ã‚¨ãƒªã‚¢åº§æ¨™ãƒ‡ãƒ¼ã‚¿
    const areaCoordinates = {
      takeo_hospital: {
        name: 'æ–°æ­¦é›„ç—…é™¢è¿‘éƒŠ',
        bounds: [[33.1780, 130.0080], [33.1890, 130.0190]],
        center: [33.1836, 130.0136]
      },
      saga_center: {
        name: 'ä½è³€å¸‚ä¸­å¿ƒéƒ¨',
        bounds: [[33.2500, 130.2800], [33.2800, 130.3200]],
        center: [33.2646, 130.2975]
      },
      karatsu_castle: {
        name: 'å”æ´¥åŸå‘¨è¾º',
        bounds: [[33.4400, 129.9600], [33.4500, 129.9800]],
        center: [33.4464, 129.9686]
      },
      nagasaki_station: {
        name: 'é•·å´é§…å‘¨è¾º',
        bounds: [[32.7400, 129.8600], [32.7600, 129.8800]],
        center: [32.7504, 129.8683]
      }
    };
    
    // åˆæœŸåŒ–
    function init() {
      // ã‚·ãƒ¼ãƒ³ä½œæˆ
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0a0a0a, 100, 2000);
      
      // ã‚«ãƒ¡ãƒ©ä½œæˆ
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
      camera.position.set(0, 100, 200);
      
      // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ä½œæˆ
      renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      
      // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
      setupLighting();
      
      // åœ°é¢ä½œæˆ
      createGround();
      
      // åˆæœŸã‚¨ãƒªã‚¢è¨­å®š
      document.getElementById('areaSelect').value = 'takeo_hospital';
      document.getElementById('areaSelect').dispatchEvent(new Event('change'));
      
      // ã‚·ãƒ¼ãƒ³ã‚¿ã‚¤ãƒˆãƒ«è¡¨ç¤º
      setTimeout(() => {
        document.getElementById('scene-title').style.opacity = '1';
        setTimeout(() => {
          document.getElementById('scene-title').style.opacity = '0';
        }, 3000);
      }, 1000);
      
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
      animate();
      
      // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
      window.addEventListener('resize', onWindowResize);
    }
    
    // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°è¨­å®š
    function setupLighting() {
      // ç’°å¢ƒå…‰
      const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
      scene.add(ambientLight);
      
      // ãƒ¡ã‚¤ãƒ³ãƒ©ã‚¤ãƒˆ
      const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
      mainLight.position.set(100, 200, 100);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 2048;
      mainLight.shadow.mapSize.height = 2048;
      scene.add(mainLight);
      
      // è£œåŠ©ãƒ©ã‚¤ãƒˆ
      const fillLight = new THREE.DirectionalLight(0x4ecdc4, 0.3);
      fillLight.position.set(-100, 100, -100);
      scene.add(fillLight);
      
      // ãƒªãƒ ãƒ©ã‚¤ãƒˆ
      const rimLight = new THREE.DirectionalLight(0xff6b35, 0.2);
      rimLight.position.set(0, 50, -200);
      scene.add(rimLight);
    }
    
    // åœ°é¢ä½œæˆ
    function createGround() {
      const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
      const groundMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x1a1a1a,
        transparent: true,
        opacity: 0.9
      });
      
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);
    }
    
    // ã‚¨ãƒªã‚¢é¸æŠæ™‚ã®å‡¦ç†
    document.getElementById('areaSelect').addEventListener('change', function() {
      const area = this.value;
      if (area !== 'custom' && areaCoordinates[area]) {
        const coords = areaCoordinates[area];
        document.getElementById('minLat').value = coords.bounds[0][0];
        document.getElementById('maxLat').value = coords.bounds[1][0];
        document.getElementById('minLng').value = coords.bounds[0][1];
        document.getElementById('maxLng').value = coords.bounds[1][1];
      }
    });
    
    // å»ºç‰©ç¾¤èª­ã¿è¾¼ã¿
    async function loadBuildings() {
      const minLat = parseFloat(document.getElementById('minLat').value);
      const maxLat = parseFloat(document.getElementById('maxLat').value);
      const minLng = parseFloat(document.getElementById('minLng').value);
      const maxLng = parseFloat(document.getElementById('maxLng').value);
      
      if (!minLat || !maxLat || !minLng || !maxLng) {
        showMessage('åº§æ¨™ç¯„å›²ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
        return;
      }
      
      showMessage('å»ºç‰©ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...', 'info');
      
      try {
        const bbox = `${minLat},${minLng},${maxLat},${maxLng}`;
        const query = `
[out:json][timeout:60];
(
  way["building"](${bbox});
  way["building:part"](${bbox});
  way["building:use"](${bbox});
  node["building"](${bbox});
);
out body;
>;
out skel qt;
        `;
        
        const response = await fetch('https://overpass-api.de/api/interpreter', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: `data=${encodeURIComponent(query)}`
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data.elements || data.elements.length === 0) {
          showMessage('å»ºç‰©ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã‚µãƒ³ãƒ—ãƒ«å»ºç‰©ã‚’ä½œæˆã—ã¾ã™ã€‚', 'error');
          createSampleBuildings();
          return;
        }
        
        processBuildingData(data, minLat, maxLat, minLng, maxLng);
        
      } catch (error) {
        console.error('ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
        showMessage(`ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚µãƒ³ãƒ—ãƒ«å»ºç‰©ã‚’ä½œæˆã—ã¾ã™ã€‚`, 'error');
        createSampleBuildings();
      }
    }
    
    // å»ºç‰©ãƒ‡ãƒ¼ã‚¿å‡¦ç†
    function processBuildingData(data, minLat, maxLat, minLng, maxLng) {
      buildings.forEach(building => scene.remove(building));
      buildings = [];
      
      const nodes = {};
      if (data.elements) {
        data.elements.forEach(element => {
          if (element.type === 'node') {
            nodes[element.id] = element;
          }
        });
      }
      
      let buildingCount = 0;
      
      if (data.elements) {
        data.elements.forEach(element => {
          if (element.type === 'way' && element.nodes && element.nodes.length > 2) {
            const building = createBuildingMesh(element, nodes, minLat, maxLat, minLng, maxLng);
            if (building) {
              scene.add(building);
              buildings.push(building);
              buildingCount++;
            }
          }
        });
      }
      
      if (buildingCount === 0) {
        showMessage('å»ºç‰©ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚µãƒ³ãƒ—ãƒ«å»ºç‰©ã‚’ä½œæˆã—ã¾ã™ã€‚', 'error');
        createSampleBuildings();
        return;
      }
      
      showMessage(`${buildingCount}å€‹ã®å»ºç‰©ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`, 'success');
      
      // ã‚«ãƒ¡ãƒ©ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š
      const centerLat = (minLat + maxLat) / 2;
      const centerLng = (minLng + maxLng) / 2;
      cameraTarget.set(
        (centerLng - minLng) * 10000,
        0,
        (centerLat - minLat) * 10000
      );
    }
    
    // å»ºç‰©ãƒ¡ãƒƒã‚·ãƒ¥ä½œæˆ
    function createBuildingMesh(way, nodes, minLat, maxLat, minLng, maxLng) {
      const coordinates = [];
      
      way.nodes.forEach(nodeId => {
        const node = nodes[nodeId];
        if (node && node.lat && node.lon) {
          coordinates.push([node.lat, node.lon]);
        }
      });
      
      if (coordinates.length < 3) return null;
      
      const latRange = maxLat - minLat;
      const lngRange = maxLng - minLng;
      const scale = 1000 / Math.max(latRange, lngRange);
      
      const points = coordinates.map(coord => {
        const x = (coord[1] - minLng) * scale;
        const z = (coord[0] - minLat) * scale;
        return new THREE.Vector3(x, 0, z);
      });
      
      let height = 10;
      let color = 0xcccccc;
      
      if (way.tags) {
        if (way.tags['building:levels']) {
          height = parseInt(way.tags['building:levels']) * 3;
        } else if (way.tags.height) {
          height = parseFloat(way.tags.height);
        }
        
        if (way.tags['building'] === 'commercial') {
          color = 0x4CAF50;
        } else if (way.tags['building'] === 'residential') {
          color = 0x2196F3;
        } else if (way.tags['building'] === 'public') {
          color = 0xFF9800;
        } else if (way.tags['building'] === 'industrial') {
          color = 0x9C27B0;
        }
      }
      
      try {
        const shape = new THREE.Shape();
        shape.moveTo(points[0].x, points[0].z);
        for (let i = 1; i < points.length; i++) {
          shape.lineTo(points[i].x, points[i].z);
        }
        shape.closePath();
        
        const extrudeSettings = {
          depth: height,
          bevelEnabled: false
        };
        
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const material = new THREE.MeshLambertMaterial({ 
          color: color,
          transparent: true,
          opacity: 0.9
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = height / 2;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        return mesh;
      } catch (error) {
        console.error('å»ºç‰©ãƒ¡ãƒƒã‚·ãƒ¥ä½œæˆã‚¨ãƒ©ãƒ¼:', error);
        return null;
      }
    }
    
    // ã‚µãƒ³ãƒ—ãƒ«å»ºç‰©ä½œæˆ
    function createSampleBuildings() {
      showMessage('ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯ã‚µãƒ³ãƒ—ãƒ«å»ºç‰©ã‚’ä½œæˆä¸­...', 'info');
      
      buildings.forEach(building => scene.remove(building));
      buildings = [];
      
      for (let i = 0; i < 30; i++) {
        const building = createSampleBuilding(i);
        if (building) {
          scene.add(building);
          buildings.push(building);
        }
      }
      
      showMessage(`${buildings.length}å€‹ã®ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯å»ºç‰©ã‚’ä½œæˆã—ã¾ã—ãŸ`, 'success');
    }
    
    // ã‚µãƒ³ãƒ—ãƒ«å»ºç‰©ä½œæˆ
    function createSampleBuilding(index) {
      const size = 15 + Math.random() * 30;
      const height = 10 + Math.random() * 40;
      const x = (index % 6 - 3) * 60;
      const z = Math.floor(index / 6) * 60 - 150;
      
      const geometry = new THREE.BoxGeometry(size, height, size);
      const colors = [0x4CAF50, 0x2196F3, 0xFF9800, 0x9C27B0, 0xE91E63, 0x00BCD4];
      const color = colors[Math.floor(Math.random() * colors.length)];
      
      const material = new THREE.MeshLambertMaterial({ 
        color: color,
        transparent: true,
        opacity: 0.9
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, height / 2, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      return mesh;
    }
    
    // ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯é–‹å§‹
    function startCinematic() {
      isCinematic = !isCinematic;
      cinematicMode = document.getElementById('cinematicMode').value;
      
      if (isCinematic) {
        showMessage('ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰é–‹å§‹', 'success');
        updateCinematicInfo();
      } else {
        showMessage('ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰åœæ­¢', 'info');
      }
    }
    
    // ã‚«ãƒ¡ãƒ©ãƒ‘ã‚¹è¨­å®š
    function setCameraPath(path) {
      cameraPath = path;
      document.querySelectorAll('.camera-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      updateCinematicInfo();
    }
    
    // ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯æƒ…å ±æ›´æ–°
    function updateCinematicInfo() {
      document.getElementById('camera-work').textContent = cameraPath;
      document.getElementById('lighting').textContent = cinematicMode;
      document.getElementById('effects').textContent = isCinematic ? 'æœ‰åŠ¹' : 'ãªã—';
      document.getElementById('music').textContent = isCinematic ? 'ã‚ªãƒ³' : 'ã‚ªãƒ•';
    }
    
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
    function showMessage(message, type) {
      const messageDiv = document.getElementById('message');
      messageDiv.className = type;
      messageDiv.textContent = message;
      
      setTimeout(() => {
        messageDiv.textContent = '';
        messageDiv.className = '';
      }, 3000);
    }
    
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
    function animate() {
      requestAnimationFrame(animate);
      
      time += 0.01;
      
      if (isCinematic) {
        updateCinematicCamera();
      }
      
      renderer.render(scene, camera);
    }
    
    // ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯ã‚«ãƒ¡ãƒ©æ›´æ–°
    function updateCinematicCamera() {
      const radius = 200;
      const height = 100 + Math.sin(time * 0.5) * 50;
      
      switch (cameraPath) {
        case 'orbit':
          camera.position.x = cameraTarget.x + Math.cos(time * 0.3) * radius;
          camera.position.y = height;
          camera.position.z = cameraTarget.z + Math.sin(time * 0.3) * radius;
          break;
          
        case 'flyover':
          camera.position.x = cameraTarget.x + Math.sin(time * 0.2) * 300;
          camera.position.y = 150 + Math.sin(time * 0.3) * 30;
          camera.position.z = cameraTarget.z + Math.cos(time * 0.2) * 300;
          break;
          
        case 'street':
          camera.position.x = cameraTarget.x + Math.sin(time * 0.1) * 100;
          camera.position.y = 5 + Math.sin(time * 0.5) * 2;
          camera.position.z = cameraTarget.z + Math.cos(time * 0.1) * 100;
          break;
          
        case 'dramatic':
          camera.position.x = cameraTarget.x + Math.sin(time * 0.4) * 250;
          camera.position.y = 80 + Math.sin(time * 0.6) * 40;
          camera.position.z = cameraTarget.z + Math.cos(time * 0.4) * 250;
          break;
      }
      
      camera.lookAt(cameraTarget);
    }
    
    // åˆæœŸåŒ–
    window.addEventListener('load', init);
  </script>
</body>
</html> 