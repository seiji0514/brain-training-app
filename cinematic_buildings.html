<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>シネマティック 3D建物群</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Meiryo', sans-serif;
      background: #000;
      overflow: hidden;
    }
    
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      z-index: 100;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 15px;
      max-width: 400px;
      border: 2px solid #ff6b35;
      backdrop-filter: blur(10px);
    }
    
    #cinematic-info {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      z-index: 100;
      background: rgba(0, 0, 0, 0.9);
      padding: 15px;
      border-radius: 15px;
      border: 2px solid #4ecdc4;
      backdrop-filter: blur(10px);
    }
    
    #scene-title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 48px;
      font-weight: bold;
      text-align: center;
      z-index: 200;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      opacity: 0;
      transition: opacity 2s;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      color: #fff;
    }
    
    input, select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ff6b35;
      border-radius: 4px;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
    }
    
    button {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      margin: 5px;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
    }
    
    button.secondary {
      background: linear-gradient(45deg, #4ecdc4, #44a08d);
    }
    
    button.secondary:hover {
      box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
    }
    
    .coordinates {
      display: flex;
      gap: 10px;
    }
    
    .coordinates input {
      flex: 1;
    }
    
    .error {
      background: rgba(255, 0, 0, 0.2);
      color: #ff6b6b;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      border: 1px solid #ff6b6b;
    }
    
    .success {
      background: rgba(0, 255, 0, 0.2);
      color: #51cf66;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      border: 1px solid #51cf66;
    }
    
    #message {
      margin-top: 10px;
    }
    
    #cinematic-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 50;
    }
    
    .film-grain {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/></filter><rect width="100" height="100" filter="url(%23noise)" opacity="0.05"/></svg>');
      opacity: 0.1;
    }
    
    .vignette {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.3) 70%);
    }
    
    #camera-path {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      z-index: 100;
      background: rgba(0, 0, 0, 0.9);
      padding: 15px 30px;
      border-radius: 20px;
      border: 2px solid #ff6b35;
      backdrop-filter: blur(10px);
    }
    
    .camera-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .camera-btn {
      background: rgba(255, 107, 53, 0.3);
      border: 1px solid #ff6b35;
      color: white;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .camera-btn:hover {
      background: rgba(255, 107, 53, 0.6);
    }
    
    .camera-btn.active {
      background: #ff6b35;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    
    <!-- シネマティックオーバーレイ -->
    <div id="cinematic-overlay">
      <div class="film-grain"></div>
      <div class="vignette"></div>
    </div>
    
    <!-- シーンタイトル -->
    <div id="scene-title">シネマティック 3D建物群</div>
    
    <div id="controls">
      <h3>🎬 シネマティック 3D建物群</h3>
      
      <div class="form-group">
        <label>エリア選択:</label>
        <select id="areaSelect">
          <option value="takeo_hospital">新武雄病院近郊</option>
          <option value="saga_center">佐賀市中心部</option>
          <option value="karatsu_castle">唐津城周辺</option>
          <option value="nagasaki_station">長崎駅周辺</option>
          <option value="custom">カスタム座標</option>
        </select>
      </div>
      
      <div class="form-group">
        <label>座標範囲:</label>
        <div class="coordinates">
          <input type="number" id="minLat" placeholder="最小緯度" step="0.0001">
          <input type="number" id="maxLat" placeholder="最大緯度" step="0.0001">
        </div>
        <div class="coordinates">
          <input type="number" id="minLng" placeholder="最小経度" step="0.0001">
          <input type="number" id="maxLng" placeholder="最大経度" step="0.0001">
        </div>
      </div>
      
      <div class="form-group">
        <label>シネマティック設定:</label>
        <select id="cinematicMode">
          <option value="dramatic">ドラマティック</option>
          <option value="action">アクション</option>
          <option value="mystery">ミステリー</option>
          <option value="romantic">ロマンティック</option>
        </select>
      </div>
      
      <button onclick="loadBuildings()">建物群読み込み</button>
      <button class="secondary" onclick="startCinematic()">シネマティック開始</button>
      <button class="secondary" onclick="createSampleBuildings()">サンプル建物作成</button>
      
      <div id="message"></div>
    </div>
    
    <div id="cinematic-info">
      <h4>🎥 シネマティック情報</h4>
      <div>カメラワーク: <span id="camera-work">静止</span></div>
      <div>ライティング: <span id="lighting">標準</span></div>
      <div>エフェクト: <span id="effects">なし</span></div>
      <div>音楽: <span id="music">オフ</span></div>
    </div>
    
    <div id="camera-path">
      <div class="camera-controls">
        <div class="camera-btn" onclick="setCameraPath('orbit')">軌道撮影</div>
        <div class="camera-btn" onclick="setCameraPath('flyover')">上空飛行</div>
        <div class="camera-btn" onclick="setCameraPath('street')">ストリート視点</div>
        <div class="camera-btn" onclick="setCameraPath('dramatic')">ドラマティック</div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let buildings = [];
    let cinematicMode = 'dramatic';
    let cameraPath = 'orbit';
    let isCinematic = false;
    let time = 0;
    let cameraTarget = new THREE.Vector3(0, 0, 0);
    
    // エリア座標データ
    const areaCoordinates = {
      takeo_hospital: {
        name: '新武雄病院近郊',
        bounds: [[33.1780, 130.0080], [33.1890, 130.0190]],
        center: [33.1836, 130.0136]
      },
      saga_center: {
        name: '佐賀市中心部',
        bounds: [[33.2500, 130.2800], [33.2800, 130.3200]],
        center: [33.2646, 130.2975]
      },
      karatsu_castle: {
        name: '唐津城周辺',
        bounds: [[33.4400, 129.9600], [33.4500, 129.9800]],
        center: [33.4464, 129.9686]
      },
      nagasaki_station: {
        name: '長崎駅周辺',
        bounds: [[32.7400, 129.8600], [32.7600, 129.8800]],
        center: [32.7504, 129.8683]
      }
    };
    
    // 初期化
    function init() {
      // シーン作成
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0a0a0a, 100, 2000);
      
      // カメラ作成
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
      camera.position.set(0, 100, 200);
      
      // レンダラー作成
      renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      
      // ライティング
      setupLighting();
      
      // 地面作成
      createGround();
      
      // 初期エリア設定
      document.getElementById('areaSelect').value = 'takeo_hospital';
      document.getElementById('areaSelect').dispatchEvent(new Event('change'));
      
      // シーンタイトル表示
      setTimeout(() => {
        document.getElementById('scene-title').style.opacity = '1';
        setTimeout(() => {
          document.getElementById('scene-title').style.opacity = '0';
        }, 3000);
      }, 1000);
      
      // アニメーションループ
      animate();
      
      // リサイズ対応
      window.addEventListener('resize', onWindowResize);
    }
    
    // ライティング設定
    function setupLighting() {
      // 環境光
      const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
      scene.add(ambientLight);
      
      // メインライト
      const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
      mainLight.position.set(100, 200, 100);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 2048;
      mainLight.shadow.mapSize.height = 2048;
      scene.add(mainLight);
      
      // 補助ライト
      const fillLight = new THREE.DirectionalLight(0x4ecdc4, 0.3);
      fillLight.position.set(-100, 100, -100);
      scene.add(fillLight);
      
      // リムライト
      const rimLight = new THREE.DirectionalLight(0xff6b35, 0.2);
      rimLight.position.set(0, 50, -200);
      scene.add(rimLight);
    }
    
    // 地面作成
    function createGround() {
      const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
      const groundMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x1a1a1a,
        transparent: true,
        opacity: 0.9
      });
      
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);
    }
    
    // エリア選択時の処理
    document.getElementById('areaSelect').addEventListener('change', function() {
      const area = this.value;
      if (area !== 'custom' && areaCoordinates[area]) {
        const coords = areaCoordinates[area];
        document.getElementById('minLat').value = coords.bounds[0][0];
        document.getElementById('maxLat').value = coords.bounds[1][0];
        document.getElementById('minLng').value = coords.bounds[0][1];
        document.getElementById('maxLng').value = coords.bounds[1][1];
      }
    });
    
    // 建物群読み込み
    async function loadBuildings() {
      const minLat = parseFloat(document.getElementById('minLat').value);
      const maxLat = parseFloat(document.getElementById('maxLat').value);
      const minLng = parseFloat(document.getElementById('minLng').value);
      const maxLng = parseFloat(document.getElementById('maxLng').value);
      
      if (!minLat || !maxLat || !minLng || !maxLng) {
        showMessage('座標範囲を入力してください', 'error');
        return;
      }
      
      showMessage('建物データを取得中...', 'info');
      
      try {
        const bbox = `${minLat},${minLng},${maxLat},${maxLng}`;
        const query = `
[out:json][timeout:60];
(
  way["building"](${bbox});
  way["building:part"](${bbox});
  way["building:use"](${bbox});
  node["building"](${bbox});
);
out body;
>;
out skel qt;
        `;
        
        const response = await fetch('https://overpass-api.de/api/interpreter', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: `data=${encodeURIComponent(query)}`
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data.elements || data.elements.length === 0) {
          showMessage('建物データが見つかりませんでした。サンプル建物を作成します。', 'error');
          createSampleBuildings();
          return;
        }
        
        processBuildingData(data, minLat, maxLat, minLng, maxLng);
        
      } catch (error) {
        console.error('データ取得エラー:', error);
        showMessage(`データ取得に失敗しました。サンプル建物を作成します。`, 'error');
        createSampleBuildings();
      }
    }
    
    // 建物データ処理
    function processBuildingData(data, minLat, maxLat, minLng, maxLng) {
      buildings.forEach(building => scene.remove(building));
      buildings = [];
      
      const nodes = {};
      if (data.elements) {
        data.elements.forEach(element => {
          if (element.type === 'node') {
            nodes[element.id] = element;
          }
        });
      }
      
      let buildingCount = 0;
      
      if (data.elements) {
        data.elements.forEach(element => {
          if (element.type === 'way' && element.nodes && element.nodes.length > 2) {
            const building = createBuildingMesh(element, nodes, minLat, maxLat, minLng, maxLng);
            if (building) {
              scene.add(building);
              buildings.push(building);
              buildingCount++;
            }
          }
        });
      }
      
      if (buildingCount === 0) {
        showMessage('建物の作成に失敗しました。サンプル建物を作成します。', 'error');
        createSampleBuildings();
        return;
      }
      
      showMessage(`${buildingCount}個の建物を読み込みました`, 'success');
      
      // カメラターゲット設定
      const centerLat = (minLat + maxLat) / 2;
      const centerLng = (minLng + maxLng) / 2;
      cameraTarget.set(
        (centerLng - minLng) * 10000,
        0,
        (centerLat - minLat) * 10000
      );
    }
    
    // 建物メッシュ作成
    function createBuildingMesh(way, nodes, minLat, maxLat, minLng, maxLng) {
      const coordinates = [];
      
      way.nodes.forEach(nodeId => {
        const node = nodes[nodeId];
        if (node && node.lat && node.lon) {
          coordinates.push([node.lat, node.lon]);
        }
      });
      
      if (coordinates.length < 3) return null;
      
      const latRange = maxLat - minLat;
      const lngRange = maxLng - minLng;
      const scale = 1000 / Math.max(latRange, lngRange);
      
      const points = coordinates.map(coord => {
        const x = (coord[1] - minLng) * scale;
        const z = (coord[0] - minLat) * scale;
        return new THREE.Vector3(x, 0, z);
      });
      
      let height = 10;
      let color = 0xcccccc;
      
      if (way.tags) {
        if (way.tags['building:levels']) {
          height = parseInt(way.tags['building:levels']) * 3;
        } else if (way.tags.height) {
          height = parseFloat(way.tags.height);
        }
        
        if (way.tags['building'] === 'commercial') {
          color = 0x4CAF50;
        } else if (way.tags['building'] === 'residential') {
          color = 0x2196F3;
        } else if (way.tags['building'] === 'public') {
          color = 0xFF9800;
        } else if (way.tags['building'] === 'industrial') {
          color = 0x9C27B0;
        }
      }
      
      try {
        const shape = new THREE.Shape();
        shape.moveTo(points[0].x, points[0].z);
        for (let i = 1; i < points.length; i++) {
          shape.lineTo(points[i].x, points[i].z);
        }
        shape.closePath();
        
        const extrudeSettings = {
          depth: height,
          bevelEnabled: false
        };
        
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const material = new THREE.MeshLambertMaterial({ 
          color: color,
          transparent: true,
          opacity: 0.9
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = height / 2;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        return mesh;
      } catch (error) {
        console.error('建物メッシュ作成エラー:', error);
        return null;
      }
    }
    
    // サンプル建物作成
    function createSampleBuildings() {
      showMessage('シネマティックサンプル建物を作成中...', 'info');
      
      buildings.forEach(building => scene.remove(building));
      buildings = [];
      
      for (let i = 0; i < 30; i++) {
        const building = createSampleBuilding(i);
        if (building) {
          scene.add(building);
          buildings.push(building);
        }
      }
      
      showMessage(`${buildings.length}個のシネマティック建物を作成しました`, 'success');
    }
    
    // サンプル建物作成
    function createSampleBuilding(index) {
      const size = 15 + Math.random() * 30;
      const height = 10 + Math.random() * 40;
      const x = (index % 6 - 3) * 60;
      const z = Math.floor(index / 6) * 60 - 150;
      
      const geometry = new THREE.BoxGeometry(size, height, size);
      const colors = [0x4CAF50, 0x2196F3, 0xFF9800, 0x9C27B0, 0xE91E63, 0x00BCD4];
      const color = colors[Math.floor(Math.random() * colors.length)];
      
      const material = new THREE.MeshLambertMaterial({ 
        color: color,
        transparent: true,
        opacity: 0.9
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, height / 2, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      return mesh;
    }
    
    // シネマティック開始
    function startCinematic() {
      isCinematic = !isCinematic;
      cinematicMode = document.getElementById('cinematicMode').value;
      
      if (isCinematic) {
        showMessage('シネマティックモード開始', 'success');
        updateCinematicInfo();
      } else {
        showMessage('シネマティックモード停止', 'info');
      }
    }
    
    // カメラパス設定
    function setCameraPath(path) {
      cameraPath = path;
      document.querySelectorAll('.camera-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      updateCinematicInfo();
    }
    
    // シネマティック情報更新
    function updateCinematicInfo() {
      document.getElementById('camera-work').textContent = cameraPath;
      document.getElementById('lighting').textContent = cinematicMode;
      document.getElementById('effects').textContent = isCinematic ? '有効' : 'なし';
      document.getElementById('music').textContent = isCinematic ? 'オン' : 'オフ';
    }
    
    // メッセージ表示
    function showMessage(message, type) {
      const messageDiv = document.getElementById('message');
      messageDiv.className = type;
      messageDiv.textContent = message;
      
      setTimeout(() => {
        messageDiv.textContent = '';
        messageDiv.className = '';
      }, 3000);
    }
    
    // ウィンドウリサイズ対応
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // アニメーションループ
    function animate() {
      requestAnimationFrame(animate);
      
      time += 0.01;
      
      if (isCinematic) {
        updateCinematicCamera();
      }
      
      renderer.render(scene, camera);
    }
    
    // シネマティックカメラ更新
    function updateCinematicCamera() {
      const radius = 200;
      const height = 100 + Math.sin(time * 0.5) * 50;
      
      switch (cameraPath) {
        case 'orbit':
          camera.position.x = cameraTarget.x + Math.cos(time * 0.3) * radius;
          camera.position.y = height;
          camera.position.z = cameraTarget.z + Math.sin(time * 0.3) * radius;
          break;
          
        case 'flyover':
          camera.position.x = cameraTarget.x + Math.sin(time * 0.2) * 300;
          camera.position.y = 150 + Math.sin(time * 0.3) * 30;
          camera.position.z = cameraTarget.z + Math.cos(time * 0.2) * 300;
          break;
          
        case 'street':
          camera.position.x = cameraTarget.x + Math.sin(time * 0.1) * 100;
          camera.position.y = 5 + Math.sin(time * 0.5) * 2;
          camera.position.z = cameraTarget.z + Math.cos(time * 0.1) * 100;
          break;
          
        case 'dramatic':
          camera.position.x = cameraTarget.x + Math.sin(time * 0.4) * 250;
          camera.position.y = 80 + Math.sin(time * 0.6) * 40;
          camera.position.z = cameraTarget.z + Math.cos(time * 0.4) * 250;
          break;
      }
      
      camera.lookAt(cameraTarget);
    }
    
    // 初期化
    window.addEventListener('load', init);
  </script>
</body>
</html> 