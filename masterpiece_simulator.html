<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>【完成版】高精度3D運転リハビリテーション・シミュレーター</title>
    <style>
        body { margin: 0; background-color: #000; color: #fff; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
            font-family: 'Helvetica Neue', 'Arial', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', 'Meiryo', sans-serif;
            font-size: 24px;
            font-weight: 300;
            text-shadow: 0 0 8px #000, 0 0 8px #000;
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <div id="info">
        高精度3D運転シミュレーター<br>
        <span style="font-size: 16px;">(社会復帰支援プログラム)</span>
    </div>
    <div id="loader">プログラムを準備中...</div>

    <!-- 外部ライブラリ (より信頼性の高いCDNから順番に読み込む) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <!-- メインプログラム -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const loaderElement = document.getElementById('loader');

            // --- 最終チェック ---
            if (typeof THREE === 'undefined') {
                loaderElement.innerHTML = 'エラー: 3Dライブラリ(Three.js)が読み込めませんでした。'; return;
            }
            if (typeof CANNON === 'undefined') {
                loaderElement.innerHTML = 'エラー: 物理エンジン(Cannon.js)が読み込めませんでした。'; return;
            }
            if (typeof THREE.GLTFLoader === 'undefined') {
                loaderElement.innerHTML = 'エラー: モデルローダーが読み込めませんでした。'; return;
            }

            loaderElement.innerHTML = '3Dモデルを読み込み中...';

            try {
                let camera, scene, renderer, world;
                let carMesh;
                const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

                // 車両物理オブジェクト
                let vehicle;
                const wheelMeshes = [];

                init();
                animate();

                function init() {
                    world = new CANNON.World();
                    world.gravity.set(0, -9.82, 0);
                    world.broadphase = new CANNON.SAPBroadphase(world);
                    world.solver.iterations = 10;
                    world.defaultContactMaterial.friction = 0;


                    const groundMaterial = new CANNON.Material("groundMaterial");
                    const wheelMaterial = new CANNON.Material("wheelMaterial");
                    const wheelGroundContactMaterial = new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
                        friction: 0.3,
                        restitution: 0,
                        contactEquationStiffness: 1000,
                    });
                    world.addContactMaterial(wheelGroundContactMaterial);


                    const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
                    groundBody.addShape(new CANNON.Plane());
                    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                    world.addBody(groundBody);


                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.set(4, 2, -5);
                    scene = new THREE.Scene();

                    new THREE.RGBELoader()
                        .setPath('https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/textures/equirectangular/')
                        .load('venice_sunset_1k.hdr', 
                        (texture) => {
                            texture.mapping = THREE.EquirectangularReflectionMapping;
                            scene.background = texture;
                            scene.environment = texture;
                        }, undefined, (err) => {
                            loaderElement.innerHTML = 'エラー: 背景の読み込みに失敗しました。';
                        });

                    const groundMesh = new THREE.Mesh(
                        new THREE.PlaneGeometry(200, 200),
                        new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.4 })
                    );
                    groundMesh.rotation.x = -Math.PI / 2;
                    groundMesh.receiveShadow = true;
                    scene.add(groundMesh);
                    
                    // 車両シャシー
                    const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.3, 2));
                    const chassisBody = new CANNON.Body({ mass: 150 });
                    chassisBody.addShape(chassisShape);
                    chassisBody.position.set(0, 1, 0);
                    chassisBody.angularVelocity.set(0, 0.5, 0);
                    
                    // 車両オブジェクト
                    vehicle = new CANNON.RaycastVehicle({
                        chassisBody: chassisBody,
                    });

                    const wheelOptions = {
                        radius: 0.5,
                        directionLocal: new CANNON.Vec3(0, -1, 0),
                        suspensionStiffness: 30,
                        suspensionRestLength: 0.3,
                        frictionSlip: 1.4,
                        dampingRelaxation: 2.3,
                        dampingCompression: 4.4,
                        maxSuspensionForce: 100000,
                        maxSuspensionTravel: 0.3,
                        customSlidingRotationalSpeed: -30,
                        useCustomSlidingRotationalSpeed: true
                    };
                    
                    const wheelPositions = [
                        new CANNON.Vec3(-1, 0, 1.7), 
                        new CANNON.Vec3(1, 0, 1.7),  
                        new CANNON.Vec3(-1, 0, -1.7),
                        new CANNON.Vec3(1, 0, -1.7) 
                    ];
                    
                    wheelPositions.forEach(pos => {
                        vehicle.addWheel({ ...wheelOptions, chassisConnectionPointLocal: pos });
                    });
                    
                    vehicle.addToWorld(world);

                    const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 32);
                    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                    
                    vehicle.wheelInfos.forEach(() => {
                        const wheelMesh = new THREE.Mesh(wheelGeo, wheelMat);
                        wheelMesh.castShadow = true;
                        wheelMeshes.push(wheelMesh);
                        scene.add(wheelMesh);
                    });
                    
                    world.addEventListener('postStep', () => {
                        for(let i=0; i<vehicle.wheelInfos.length; i++) {
                            vehicle.updateWheelTransform(i);
                            const t = vehicle.wheelInfos[i].worldTransform;
                            wheelMeshes[i].position.copy(t.position);
                            wheelMeshes[i].quaternion.copy(t.quaternion);
                        }
                    });


                    const dracoLoader = new THREE.DRACOLoader().setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                    new THREE.GLTFLoader().setDRACOLoader(dracoLoader).load('https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/models/ferrari.glb', 
                    (gltf) => {
                        carMesh = gltf.scene;
                        carMesh.traverse(child => { if (child.isMesh) child.castShadow = true; });
                        carMesh.scale.set(0.5, 0.5, 0.5);
                        scene.add(carMesh);
                        loaderElement.style.display = 'none';
                    }, undefined, (err) => {
                        loaderElement.innerHTML = 'エラー: 車両モデルの読み込みに失敗しました。';
                    });

                    renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.shadowMap.enabled = true;
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 0.85;
                    document.body.appendChild(renderer.domElement);

                    document.addEventListener('keydown', (e) => {
                        const maxSteerVal = 0.5;
                        const maxForce = 1000;
                        
                        switch(e.key) {
                            case 'w':
                            case 'ArrowUp':
                                vehicle.applyEngineForce(-maxForce, 2);
                                vehicle.applyEngineForce(-maxForce, 3);
                                break;
                            case 's':
                            case 'ArrowDown':
                                vehicle.applyEngineForce(maxForce, 2);
                                vehicle.applyEngineForce(maxForce, 3);
                                break;
                           case 'a':
                           case 'ArrowLeft':
                                vehicle.setSteeringValue(maxSteerVal, 0);
                                vehicle.setSteeringValue(maxSteerVal, 1);
                                break;
                            case 'd':
                            case 'ArrowRight':
                                vehicle.setSteeringValue(-maxSteerVal, 0);
                                vehicle.setSteeringValue(-maxSteerVal, 1);
                                break;
                        }
                    });

                    document.addEventListener('keyup', (e) => {
                         switch(e.key) {
                            case 'w':
                            case 'ArrowUp':
                            case 's':
                            case 'ArrowDown':
                                vehicle.applyEngineForce(0, 2);
                                vehicle.applyEngineForce(0, 3);
                                break;
                            case 'a':
                            case 'ArrowLeft':
                            case 'd':
                            case 'ArrowRight':
                                vehicle.setSteeringValue(0, 0);
                                vehicle.setSteeringValue(0, 1);
                                break;
                        }
                    });

                    window.addEventListener('resize', onWindowResize);
                }

                function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }

                function animate() {
                    requestAnimationFrame(animate);
                    world.step(1 / 60);

                    if (carMesh && vehicle) {
                        const chassisBody = vehicle.chassisBody;
                        carMesh.position.copy(chassisBody.position);
                        carMesh.quaternion.copy(chassisBody.quaternion);
                        
                        const relativeCameraOffset = new THREE.Vector3(0, 4, 8);
                        const cameraOffset = carMesh.localToWorld(relativeCameraOffset);
                        camera.position.lerp(cameraOffset, 0.1);
                        camera.lookAt(carMesh.position);
                    }
                    renderer.render(scene, camera);
                }
            } catch (e) {
                console.error("致命的なエラー:", e);
                loaderElement.innerHTML = `致命的なエラーが発生しました: ${e.message}。`;
            }
        });
    </script>
</body>
</html> 